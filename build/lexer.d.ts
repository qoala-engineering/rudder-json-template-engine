import { Token, TokenType } from './types';
export declare class JsonTemplateLexer {
    private readonly codeChars;
    private buf;
    private idx;
    constructor(template: string);
    init(): void;
    currentIndex(): number;
    reset(idx: number): void;
    getCode(start: number, end: number): string;
    match(value?: string, steps?: number): boolean;
    matchAssignment(): boolean;
    matchLiteral(): boolean;
    matchINT(steps?: number): boolean;
    matchToArray(): boolean;
    matchCompileTimeExpr(): boolean;
    matchMappings(): boolean;
    matchSimplePath(): boolean;
    matchRichPath(): boolean;
    matchJsonPath(): boolean;
    matchPathType(): boolean;
    matchPath(): boolean;
    matchObjectContextProp(): boolean;
    matchSpread(): boolean;
    matchIncrement(): boolean;
    matchDecrement(): boolean;
    matchPathPartSelector(): boolean;
    matchPathSelector(): boolean;
    matchTokenType(tokenType: TokenType, steps?: number): boolean;
    matchID(steps?: number): boolean;
    matchEOT(): boolean;
    private static isOperator;
    matchKeyword(): boolean;
    matchKeywordValue(val: string): boolean;
    matchContains(): boolean;
    matchEmpty(): boolean;
    matchSize(): boolean;
    matchSubsetOf(): boolean;
    matchAnyOf(): boolean;
    matchNoneOf(): boolean;
    matchIN(): boolean;
    matchNotIN(): boolean;
    matchFunction(): boolean;
    matchNew(): boolean;
    matchTypeOf(): boolean;
    matchAwait(): boolean;
    matchLambda(): boolean;
    expect(value: any): void;
    lookahead(steps?: number): Token;
    private isLineCommentStart;
    private isLineCommentEnd;
    private isBlockCommentStart;
    private isBlockCommentEnd;
    private skipLineComment;
    private skipBlockComment;
    private isWhiteSpace;
    private skipWhitespace;
    private skipInput;
    private advance;
    value(): any;
    ignoreTokens(numTokens: number): void;
    lex(): Token;
    static isLiteralToken(token: Token): boolean;
    throwUnexpectedToken(token?: Token): never;
    private static throwError;
    private static isDigit;
    private static isIdStart;
    private static isIdPart;
    private static validateID;
    private scanID;
    private scanString;
    scanInteger(): Token | undefined;
    private scanPunctuatorForDots;
    private scanPunctuatorForEquality;
    private scanPunctuatorForRepeatedTokens;
    private scanSingleCharPunctuators;
    private scanPunctuatorForQuestionMarks;
    private scanPunctuatorForPaths;
    private scanPunctuatorForArithmeticAssignment;
    private static isValidRegExp;
    private getRegExpModifiers;
    private scanRegularExpressions;
    private scanPunctuator;
}
//# sourceMappingURL=lexer.d.ts.map