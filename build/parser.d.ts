import { JsonTemplateLexer } from './lexer';
import { EngineOptions, Expression } from './types';
export declare class JsonTemplateParser {
    private lexer;
    private options?;
    private pathTypesStack;
    private loopCount;
    constructor(lexer: JsonTemplateLexer, options?: EngineOptions);
    parse(): Expression;
    private parseEndOfStatement;
    private parseStatements;
    private static validateStatements;
    private parseStatementsExpr;
    private parseStatementExpr;
    private parseAssignmentExpr;
    private parseBaseExpr;
    private parseNextExpr;
    private parsePathPart;
    private parsePathParts;
    private parseContextVariable;
    private parsePathOptions;
    private parsePathRoot;
    private getInferredPathType;
    private createPathResult;
    private parsePathType;
    private parsePathTypeExpr;
    private parsePath;
    private static createArrayIndexFilterExpr;
    private static createArrayFilterExpr;
    private parseSelector;
    private parseRangeFilterExpr;
    private parseArrayIndexFilterExpr;
    private parseArrayFilter;
    private parseObjectFilter;
    private parseObjectFiltersExpr;
    private parseLoopControlExpr;
    private parseCurlyBlockExpr;
    private parseConditionalBodyExpr;
    private parseConditionalExpr;
    private parseLoopExpr;
    private parseJSONObjectFilter;
    private parseAllFilter;
    private parseArrayFilterExpr;
    private combineExpressionsAsBinaryExpr;
    private parseArrayCoalesceExpr;
    private parseCoalesceExpr;
    private parseLogicalORExpr;
    private parseLogicalANDExpr;
    private parseEqualityExpr;
    private parseInExpr;
    private parseRelationalExpr;
    private parseShiftExpr;
    private parseAdditiveExpr;
    private parseMultiplicativeExpr;
    private parsePowerExpr;
    private parsePrefixIncreamentExpr;
    private static convertToID;
    private parsePostfixIncreamentExpr;
    private parseUnaryExpr;
    private shouldSkipPathParsing;
    private parsePathAfterExpr;
    private static createLiteralExpr;
    private parseLiteralExpr;
    private parseIDPath;
    private parseObjectDefVars;
    private parseNormalDefVars;
    private parseDefinitionExpr;
    private parseFunctionCallArgs;
    private parseFunctionCallExpr;
    private parseFunctionDefinitionParam;
    private parseFunctionDefinitionParams;
    private parseFunctionExpr;
    private parseObjectKeyExpr;
    private parseShortKeyValueObjectPropExpr;
    private parseSpreadObjectPropExpr;
    private getObjectPropContextVar;
    private parseNormalObjectPropExpr;
    private parseObjectPropExpr;
    private parseObjectExpr;
    private parseCommaSeparatedElements;
    private parseSpreadExpr;
    private parseArrayExpr;
    private parseBlockExpr;
    private parseAsyncFunctionExpr;
    private parseLambdaExpr;
    private parseCompileTimeBaseExpr;
    private parseCompileTimeExpr;
    private parseNumber;
    private parseFloatingNumber;
    private parseReturnExpr;
    private parseThrowExpr;
    private parseKeywordBasedExpr;
    private static isValidMapping;
    private static convertMappingsToFlatPaths;
    private parseMappings;
    private parsePrimaryExpr;
    private shouldPathBeConvertedAsBlock;
    private static convertToBlockExpr;
    private static ignoreEmptySelectors;
    private static combinePathOptionParts;
    private static convertToFunctionCallExpr;
    private static isArrayFilterExpressionSimple;
    private static isSimplePathPart;
    private static isSimplePath;
    private static isRichPath;
    private static setPathTypeIfNotJSON;
    private updatePathExpr;
    private static parseBaseExprFromTemplate;
}
//# sourceMappingURL=parser.d.ts.map